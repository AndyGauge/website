<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on Tokio - The asynchronous run-time for the Rust programming language.</title>
    <link>https://tokio.rs/docs/</link>
    <description>Recent content in Docs on Tokio - The asynchronous run-time for the Rust programming language.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://tokio.rs/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>What is Tokio?</title>
      <link>https://tokio.rs/docs/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/overview/</guid>
      <description>Tokio allows developers to write asynchronous programs in the Rust programming language. Instead of synchronously waiting for long-running operations like reading a file or waiting for a timer to complete before moving on to the next thing, Tokio allows developers to write programs where execution continues while the long-running operations are in progress.
More specifically, Tokio is an event-driven, non-blocking I/O platform for writing asynchronous applications with Rust. At a high level, it provides a few major components:</description>
    </item>
    
    <item>
      <title>Hello World!</title>
      <link>https://tokio.rs/docs/getting-started/hello-world/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/getting-started/hello-world/</guid>
      <description>To kick off our tour of Tokio, we will start with the obligatory &amp;ldquo;hello world&amp;rdquo; example. This program will create a TCP stream and write &amp;ldquo;hello, world!&amp;rdquo; to the stream. The difference between this and a Rust program that writes to a TCP stream without Tokio is that this program won&amp;rsquo;t block program execution when the stream is created or when our &amp;ldquo;hello, world!&amp;rdquo; message is written to the stream.</description>
    </item>
    
    <item>
      <title>Runtime Model</title>
      <link>https://tokio.rs/docs/getting-started/runtime-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/getting-started/runtime-model/</guid>
      <description>Now we will go over the Tokio / futures runtime model. Tokio is built on top of the futures crate and uses its runtime model. This allows it to interop with other libraries also using the futures crate.
Note: This runtime model is very different than async libraries found in other languages. While, at a high level, APIs can look similar, the way code gets executed differs.
Synchronous Model First, let&amp;rsquo;s talk briefly about the synchronous (or blocking) model.</description>
    </item>
    
    <item>
      <title>Futures</title>
      <link>https://tokio.rs/docs/getting-started/futures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/getting-started/futures/</guid>
      <description>Futures, hinted at earlier in the guide, are the building block used to manage asynchronous logic. They are the underlying asynchronous abstraction used by Tokio.
The future implementation is provided by the futures crate. However, for convenience, Tokio re-exports a number of the types.
What Are Futures? A future is a value that represents the completion of an asynchronous computation. Usually, the future completes due to an event that happens elsewhere in the system.</description>
    </item>
    
    <item>
      <title>Tasks</title>
      <link>https://tokio.rs/docs/getting-started/tasks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/getting-started/tasks/</guid>
      <description>Tasks are the application&amp;rsquo;s &amp;ldquo;unit of logic&amp;rdquo;. They are similar to Go&amp;rsquo;s goroutine and Erlang&amp;rsquo;s process, but asynchronous. In other words, tasks are asynchronous green threads.
Given that a task runs an asynchronous bit of logic, they are represented by the Future trait. The task&amp;rsquo;s future implementation completes with a () value once the task is done processing.
Tasks are passed to executors, which handle scheduling the task. An executor usually is scheduling many tasks across a single or small set of threads.</description>
    </item>
    
    <item>
      <title>I/O with Tokio</title>
      <link>https://tokio.rs/docs/getting-started/io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/getting-started/io/</guid>
      <description>The tokio crate comes with TCP and UDP networking types. Unlike the types in std, Tokio&amp;rsquo;s networking types are based on the poll model and will notify the task executors when their readiness states change (data is received and write buffers are flushed). In the tokio::net module you&amp;rsquo;ll find types like TcpListener, TcpStream, and UdpSocket.
All of these types provide both a future API as well as a poll API.</description>
    </item>
    
    <item>
      <title>Example: A Chat Server</title>
      <link>https://tokio.rs/docs/getting-started/chat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/getting-started/chat/</guid>
      <description>We&amp;rsquo;re going to use what has been covered so far to build a chat server. This is a non-trivial Tokio server application.
The server is going to use a line-based protocol. Lines are terminated by \r\n. This is compatible with telnet, so we will just use telnet for the client. When a client connects, it must identify itself by sending a line containing its &amp;ldquo;nick&amp;rdquo; (i.e., some name used to identify the client amongst its peers).</description>
    </item>
    
    <item>
      <title>I/O Overview</title>
      <link>https://tokio.rs/docs/io/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/io/overview/</guid>
      <description>Rust provides types, traits, and helpers for performing synchronous I/O operations, such as working with TCP, UDP, and, reading from and writing to files.
The tokio crate improves on those operations by providing non-blocking versions. Tokio provides the high level interfaces to asynchronous I/O for
 TCP sockets UDP sockets Unix sockets File operations  Blocking vs Non-Blocking Synchronous operations evaluate in a guaranteed sequential manner, and require expressions to complete before the next operation executes.</description>
    </item>
    
    <item>
      <title>Reading and Writing Data</title>
      <link>https://tokio.rs/docs/io/reading_writing_data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/io/reading_writing_data/</guid>
      <description>This page has not been worked on yet. If you&amp;rsquo;d like to contribute visit the doc-push repo.</description>
    </item>
    
    <item>
      <title>The Poll API</title>
      <link>https://tokio.rs/docs/io/poll/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/io/poll/</guid>
      <description>This page has not been worked on yet. If you&amp;rsquo;d like to contribute visit the doc-push repo.</description>
    </item>
    
    <item>
      <title>Implementing Async Read/Write</title>
      <link>https://tokio.rs/docs/io/async_read_write/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/io/async_read_write/</guid>
      <description>This page has not been worked on yet. If you&amp;rsquo;d like to contribute visit the doc-push repo.</description>
    </item>
    
    <item>
      <title>Filesystem APIs</title>
      <link>https://tokio.rs/docs/io/filesystem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/io/filesystem/</guid>
      <description>This page has not been worked on yet. If you&amp;rsquo;d like to contribute visit the doc-push repo.</description>
    </item>
    
    <item>
      <title>Datagram APIs</title>
      <link>https://tokio.rs/docs/io/datagrams/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/io/datagrams/</guid>
      <description>This page has not been worked on yet. If you&amp;rsquo;d like to contribute visit the doc-push repo.</description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>https://tokio.rs/docs/futures-streams-sinks/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/futures-streams-sinks/overview/</guid>
      <description>This page has not been worked on yet. If you&amp;rsquo;d like to contribute visit the doc-push repo.</description>
    </item>
    
    <item>
      <title>Working with Futures</title>
      <link>https://tokio.rs/docs/futures-streams-sinks/futures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/futures-streams-sinks/futures/</guid>
      <description>This page has not been worked on yet. If you&amp;rsquo;d like to contribute visit the doc-push repo.</description>
    </item>
    
    <item>
      <title>Working with Streams</title>
      <link>https://tokio.rs/docs/futures-streams-sinks/streams/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/futures-streams-sinks/streams/</guid>
      <description>This page has not been worked on yet. If you&amp;rsquo;d like to contribute visit the doc-push repo.</description>
    </item>
    
    <item>
      <title>Working with Sinks</title>
      <link>https://tokio.rs/docs/futures-streams-sinks/sinks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/futures-streams-sinks/sinks/</guid>
      <description>This page has not been worked on yet. If you&amp;rsquo;d like to contribute visit the doc-push repo.</description>
    </item>
    
    <item>
      <title>Putting It Together</title>
      <link>https://tokio.rs/docs/futures-streams-sinks/putting-it-together/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/futures-streams-sinks/putting-it-together/</guid>
      <description>This page has not been worked on yet. If you&amp;rsquo;d like to contribute visit the doc-push repo.</description>
    </item>
    
    <item>
      <title>Timers</title>
      <link>https://tokio.rs/docs/going-deeper/timers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/going-deeper/timers/</guid>
      <description>When writing a network based application, it is common to need to perform actions based on time.
 Run some code after a set period of time. Cancel a running operation that takes too long. Repeatedly perform an action at an interval.  These use cases are handled by using the various timer APIs that are provided in the timer module.
Running code after a period of time In this case, we want to perform a task after a set period of time.</description>
    </item>
    
    <item>
      <title>Essential combinators</title>
      <link>https://tokio.rs/docs/going-deeper/futures-mechanics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/going-deeper/futures-mechanics/</guid>
      <description>We saw a few of the most important combinators in the futures and streams overviews. Here we&amp;rsquo;ll take a look at a few more. It&amp;rsquo;s also worth spending some time with the trait documentation to familiarize yourself with the full range of combinators available (cheatsheet).
Some concrete futures and streams Any value can be turned into an immediately complete future. There are a few functions in the future module for creating such a future:</description>
    </item>
    
    <item>
      <title>Returning futures</title>
      <link>https://tokio.rs/docs/going-deeper/returning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/going-deeper/returning/</guid>
      <description>When working with futures, one of the first things you&amp;rsquo;re likely to need to do is to return a Future. As with Iterators, however, doing so can be a little tricky. There are several options, listed from most to least ergonomic:
 Trait objects impl Trait Named types Custom types  Trait objects First, you always have the option of returning a boxed trait object:
# extern crate futures; # use std::io; # use futures::Future; # fn main() {} fn foo() -&amp;gt; Box&amp;lt;Future&amp;lt;Item = u32, Error = io::Error&amp;gt;&amp;gt; { // .</description>
    </item>
    
    <item>
      <title>Working with framed streams</title>
      <link>https://tokio.rs/docs/going-deeper/frames/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/going-deeper/frames/</guid>
      <description>Tokio has helpers to transform a stream of bytes into a stream of frames. Examples of byte streams include TCP connections, pipes, file objects and the standard input and output file descriptors. In Rust, streams are easily identified because they implement the Read and Write traits.
One of the simplest forms of framed message is the line delimited message. Each message ends with a \n character. Let&amp;rsquo;s look at how one would implement a stream of line delimited messages with tokio.</description>
    </item>
    
    <item>
      <title>Building a runtime</title>
      <link>https://tokio.rs/docs/going-deeper/building-runtime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/going-deeper/building-runtime/</guid>
      <description>The runtime ‒ all the pieces needed to run an event driven application ‒ is already available. You don&amp;rsquo;t need to know this if you want to just use tokio. However, it may be useful to know what happens under the hood, both to gain some more understanding of the details in case something goes wrong, and to be able to customize it beyond what the runtime Builder supports.</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://tokio.rs/docs/internals/intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/internals/intro/</guid>
      <description>The internals section provides an in-depth guide of Tokio&amp;rsquo;s internals. It expects the reader already has a good understanding of how to use Tokio. Those unfamiliar with Tokio should start with the getting started guide.
 Runtime model - An overview of Tokio&amp;rsquo;s asynchronous runtime model. Non-blocking I/O - Implementation details of Tokio&amp;rsquo;s network related types (TCP, UDP, &amp;hellip;).  </description>
    </item>
    
    <item>
      <title>Runtime model</title>
      <link>https://tokio.rs/docs/internals/runtime-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/internals/runtime-model/</guid>
      <description>Applications written using Tokio are organized across a large number of small, non-blocking tasks. A Tokio task is similar to a goroutine or an Erlang process, but is non-blocking. They are designed to be lightweight, can be spawned fast, and maintain low scheduling overhead. They are also non-blocking, as such operations that are not able to finish immediately must still return immediately. Instead of returning the result of the operation, they return a value indicating that the operation is in progress.</description>
    </item>
    
    <item>
      <title>Non-blocking I/O</title>
      <link>https://tokio.rs/docs/internals/net/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tokio.rs/docs/internals/net/</guid>
      <description>This section describes the network resources and drivers provided by Tokio. This component provides one of Tokio&amp;rsquo;s primary functions: non-blocking, event-driven, networking provided by the appropriate operating system primitives (epoll, kqueue, IOCP, &amp;hellip;). It is modeled after the resource and driver pattern described in the previous section.
The network driver is built using mio and network resources are backed by types that implement Evented.
This guide will be focused on TCP types.</description>
    </item>
    
  </channel>
</rss>